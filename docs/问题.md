## project 
### c++
1.声明为const函数，实现时也要写const
2.类声明时指定了参数的默认值，在是实现时不需要再写默认值了
3.初始化表先于函数体执行
4.ctime是同一块静态局部内存地址，不能多次操作，会覆盖，构造一个匿名string,std::string(ctime(&sj.sj_stime)).c_str(),
且堆内存中地址不同。在数据区，静态内存
5.包体解析可以用结构体，也可以按指针长度计算
6.bool service_c::error(acl::socket_stream *conn, short errnumb, char const *format, ...) 
变长参数表
va_list ap;
va_start(ap, format);
vsnprintf(errdesc, ERROR_DESC_SIZE, format, ap);
va_end(ap);
7.线程封装思路：
线程有属性和行为，抽象出来类型
```cpp
class pthread{
  // 属性
  // 行为 启动
public:
  void start(){
    // pthread_create(..., ..., run, this);
  }
protected:
  static void* run(void *arg){
    // 类型转换
    return ((Thread*)arg)->run();// 基类对象指针调用子类的run()
 } 
 virtual void* run()=0;// 纯虚函数 概念的函数  
}
class MyThread:public Thread{
protected:
  void* run(){
    // 线程执行的代码 多态
  }
}

MyThread thread();
thread.start();// 调用基类的start函数
// this指向thread
```
8.迭代器
```cpp
// 遍历组表中的每一个组
for (std::map<std::string, std::list<storage_info_t> >::iterator
	group = g_groups.begin(); group != g_groups.end(); ++group)
	// 遍历该组中的每一台存储服务器
	for (std::list<storage_info_t>::iterator si =
		group->second.begin(); si != group->second.end(); ++si)
```
> 当你通过迭代器访问 std::map 或其他容器类型的元素时，得到的是一个指向 std::pair 对象的迭代器，此时需要使用 -> 运算符来访问 std::pair 对象的成员。
> 对于直接定义的 std::pair 对象，可以使用 . 运算符来访问其成员；而对于通过迭代器访问容器元素返回的 std::pair 对象，需要使用 -> 运算符来访问其成员。
9.基于框架编程的基本套路
流程化东西放到基类里，把需要我介入的工作以函数的形式包装后，在基类中以虚函数来体现；子类中覆盖虚函数
10.id服务器只有一份
11.头文件防卫
`#pragma once`：这是一种非标准的预处理指令，许多编译器支持它。当编译器遇到 #pragma once 时，它会确保当前头文件只包含一次，从而避免重复包含的问题。相比头文件防御声明，#pragma once 的写法更简洁，不需要手动编写条件判断。然而，由于它是非标准的预处理指令，可能不是所有的编译器都支持。

头文件防御声明（`Header Guard`）：头文件防御声明是一种标准的预处理指令，用于确保头文件只被包含一次。它通常使用条件编译指令 #ifndef、#define 和 #endif 组合来实现。具体的做法是在头文件的开头添加以下代码：
## MySQL
1.mysql_config --cflags 输出路径
g++ -c 05_db.h -I/usr/include/acl-lib/acl_cpp -I../01_common `mysql_config --cflags`
-I 选项只是指定了头文件的搜索路径，它告诉编译器在编译过程中去哪里查找头文件。指定搜索路径并不意味着所有位于该路径下的头文件都会被自动包含进来。